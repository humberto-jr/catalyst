SHELL = /bin/sh

#
# GNU Scientific Library: The installation path of GSL must be provided in the
# GSL_DIR variable, and it's to be validated by the check_gsl_dir rule defined
# below. The default path of GSL is /usr/local, but it isn't used herein because
# it exists in most systems even if GSL is not installed.
#

GSL_DIR =
LINEAR_ALGEBRA = GSL
CHECKLIST = check_gsl_dir

#
# Default compiler: GNU g++ (8.3.0 or higher) is the default option when the CC
# variable is omitted. The Intel icx compiler (previously icpc) uses the same
# flags as g++, thus the makefile will use the same CFLAGS and LDFLAGS variables.
# The use of OpenMP is implied. Valid values for CC are: g++, icx, icpc, clang++,
# ibm-clang++ and pgc++.
#

CC = g++
LDFLAGS = -L$(GSL_DIR)/lib -lgsl -lgslcblas -ldl -lm
CFLAGS = -std=c++17 -pedantic -Wall -Wconversion -fopenmp -O3 -I$(GSL_DIR)/include

#
# MPI wrappers: If the CC variable is set to an MPI wrapper of a given compiler
# (e.g., CC=mpic++), then the internal variable USE_MPI=yes is used to trigger
# all MPI-related configuration and the C++ branches using MPI.
#

USE_MPI = no
OPENMPI_DIR = none

ifeq ($(CC), mpic++)
	USE_MPI = yes
endif

ifeq ($(CC), mpicxx)
	USE_MPI = yes
endif

ifeq ($(CC), mpiicpc)
	USE_MPI = yes
endif

ifeq ($(CC), mpiicx)
	USE_MPI = yes
endif

ifeq ($(CC), mpiCC)
	USE_MPI = yes
endif

#
# LLVM clang++ compiler:
#

ifeq ($(CC), clang++)
	override CFLAGS = -std=c++17 -pedantic-errors -Wall -fopenmp=libomp -O3 -I$(GSL_DIR)/include
endif

#
# IBM Open XL compiler (clang frontend): The classic XL compilers didn't support
# C++17.
#

ifeq ($(CC), ibm-clang++)
	override CFLAGS = -std=c++17 -pedantic-errors -Wall -fopenmp=libomp -O3 -I$(GSL_DIR)/include
endif

#
# PGI pgc++ compiler:
#

ifeq ($(CC), pgc++)
	# NOTE: As of Sep. 2024, pgc++ has only partial support for C++17.
	override CFLAGS = --c++17 -pedantic -Werror -fast -mp=bind -m64 -I$(GSL_DIR)/include
endif

#
# Nvidia nvcc compiler: Since there is only one CUDA compiler, instead of using the CC
# variable to set the compiler name and presets, use the variable USE_CUDA=yes. The CC
# variable and its CFLAGS are passed to nvcc as the host compiler for the C++ parts of
# the code.
#

USE_CUDA = no

NVCC = nvcc
NVFLAGS = -std=c++17 --Werror all-warnings --threads 0 -DUSE_CUDA

ifeq ($(USE_CUDA), yes)
	CFLAGS += -DUSE_CUDA
	CHECKLIST += check_cuda_dir
	LINEAR_ALGEBRA_INC = -I$(CUDA_PATH)/include
	LINEAR_ALGEBRA_LIB = -lcublas -L$(CUDA_PATH)/lib64
endif

#
# Fortran compilers: If linkage of object files generated by Fortran compilers is
# needed, the variable FC is used to set the compiler name, and the core libraries
# will be added to LDFLAGS. Valid values for FC are: xlf, xlf90, gfortran and ifort.
# Undefined references to Fortran symbols are likely to be solved by setting FC.
#

FC = none

#
# Intel MKL: Only for GNU g++ and Intel icx (icpc) compilers. The environment
# variable MKLROOT is used and needs to have been exported elsewhere.
#

ifeq ($(LINEAR_ALGEBRA), MKL)
	CHECKLIST += check_mkl_dir
	LINEAR_ALGEBRA_INC = -DMKL_ILP64 -m64 -I$(MKLROOT)/include -DUSE_MKL

	ifeq ($(CC), icpc)
		LINEAR_ALGEBRA_LIB = -parallel -Wl,--start-group $(MKLROOT)/lib/intel64/libmkl_intel_ilp64.a $(MKLROOT)/lib/intel64/libmkl_intel_thread.a $(MKLROOT)/lib/intel64/libmkl_core.a -Wl,--end-group -liomp5 -lpthread -lm -ldl
	endif

	ifeq ($(CC), mpiicpc)
		LINEAR_ALGEBRA_LIB = -parallel -Wl,--start-group $(MKLROOT)/lib/intel64/libmkl_intel_ilp64.a $(MKLROOT)/lib/intel64/libmkl_intel_thread.a $(MKLROOT)/lib/intel64/libmkl_core.a -Wl,--end-group -liomp5 -lpthread -lm -ldl
	endif

	ifeq ($(CC), g++)
		LINEAR_ALGEBRA_LIB = -Wl,--start-group $(MKLROOT)/lib/intel64/libmkl_intel_ilp64.a $(MKLROOT)/lib/intel64/libmkl_gnu_thread.a $(MKLROOT)/lib/intel64/libmkl_core.a -Wl,--end-group -lgomp -lpthread -lm -ldl
	endif

	ifeq ($(CC), mpic++)
		LINEAR_ALGEBRA_LIB = -Wl,--start-group $(MKLROOT)/lib/intel64/libmkl_intel_ilp64.a $(MKLROOT)/lib/intel64/libmkl_gnu_thread.a $(MKLROOT)/lib/intel64/libmkl_core.a -Wl,--end-group -lgomp -lpthread -lm -ldl
	endif
endif

#
# LAPACKE, LAPACK and BLAS libraries: The default installation path is /usr/local.
# The variables BLAS_CONFIG and LAPACK_CONFIG are only used to build the libraries
# from source in the lapacke rule.
#

LAPACKE_DIR =
LAPACK_DIR = $(LAPACKE_DIR)
BLAS_DIR = $(LAPACKE_DIR)

ifeq ($(LINEAR_ALGEBRA), LAPACKE)
	CHECKLIST += check_lapacke_dir
	LINEAR_ALGEBRA_INC = -I$(LAPACKE_DIR)/include -DUSE_LAPACKE
	LINEAR_ALGEBRA_LIB = -L$(LAPACKE_DIR)/lib -L$(LAPACKE_DIR)/lib64 -llapacke -llapack -lrefblas -lm
endif

BLAS_CONFIG = FORTRAN=$(FC)
LAPACK_CONFIG = FORTRAN=$(FC) LOADER=$(FC) CC=$(CC) NOOPT=-O0 TIMER=NONE

ifeq ($(FC), gfortran)
	BLAS_CONFIG += OPTS=-O3
	LAPACK_CONFIG += CFLAGS=-O3 OPTS=-O3
endif

ifeq ($(FC), ifort)
	BLAS_CONFIG += OPTS=-O3
	LAPACK_CONFIG += CFLAGS=-O3 OPTS=-O3
endif

ifeq ($(FC), xlf)
	BLAS_CONFIG += OPTS="-qstrict -O5"
	LAPACK_CONFIG += CFLAGS="-qstrict -O5" OPTS="-qstrict -O5"
endif

ifeq ($(FC), xlf90)
	BLAS_CONFIG += OPTS="-qstrict -O5"
	LAPACK_CONFIG += CFLAGS="-qstrict -O5" OPTS="-qstrict -O5"
endif

#
# IBM ESSL:
# FIXME: This hasn't been tested in great detail, and the C++ specific impl.
# isn't ready (earlier tests used C and Fortran).
#

ESSL_DIR =

ifeq ($(LINEAR_ALGEBRA), ESSL)
	CFLAGS += -DUSE_ESSL
	CHECKLIST += check_essl_dir
	LINEAR_ALGEBRA_INC = -I$(ESSL_DIR)/include -DUSE_ESSL
	LINEAR_ALGEBRA_LIB = -L$(ESSL_DIR)/lib64 -lesslbg -lm
endif

#
# MAGMA library:
#

MAGMA_DIR = /usr/local/magma

ifeq ($(LINEAR_ALGEBRA), MAGMA)
	CFLAGS += -DUSE_MAGMA
	CHECKLIST += check_magma_dir
	LINEAR_ALGEBRA_INC += -I$(MAGMA_DIR)/include -DADD_
	LINEAR_ALGEBRA_LIB += -L$(MAGMA_DIR)/lib -lmagma -lm
endif

#
# ATLAS library:
#

ATLAS_DIR = /usr/local/atlas

ifeq ($(LINEAR_ALGEBRA), ATLAS)
	CHECKLIST += check_atlas_dir
	LINEAR_ALGEBRA_INC = -I$(ATLAS_DIR)/include -DUSE_ATLAS
	LINEAR_ALGEBRA_LIB = -L$(ATLAS_DIR)/lib -latlas -lptcblas -lm
endif

#
# Fortran core libraries: This is done late because core libraries are appended
# in the rightmost position within the linking command line.
#

XLF_DIR = /opt/ibmcmp/xlf

ifeq ($(FC), xlf)
	LDFLAGS += -L$(XLF_DIR)/lib -lxlf90 -lxl -lxlfmath

	ifeq ($(LINEAR_ALGEBRA), LAPACKE)
		LINEAR_ALGEBRA_LIB += L$(XLF_DIR)/lib -lxlf90 -lxl -lxlfmath
	endif
endif

ifeq ($(FC), xlf90)
	LDFLAGS += -L$(XLF_DIR)/lib -lxlf90 -lxl -lxlfmath

	ifeq ($(LINEAR_ALGEBRA), LAPACKE)
		LINEAR_ALGEBRA_LIB += -L$(XLF_DIR)/lib -lxlf90 -lxl -lxlfmath
	endif
endif

ifeq ($(FC), gfortran)
	LDFLAGS += -lgfortran

	ifeq ($(LINEAR_ALGEBRA), LAPACKE)
		LINEAR_ALGEBRA_LIB += -lgfortran
	endif
endif

ifeq ($(FC), ifort)
	LDFLAGS += -lifcore

	ifeq ($(LINEAR_ALGEBRA), LAPACKE)
		LINEAR_ALGEBRA_LIB += -lifcore
	endif
endif

#
# nvcc flags: The CFLAGS and LINEAR_ALGEBRA_INC are passed down to the host compiler
# set in CC by means of nvcc's flag "--compiler-options". This is done at the very
# last step before compilation to make sure the CFLAGS are no longer mutating as the
# makefile is traversed.
#

ifeq ($(USE_CUDA), yes)
	NVFLAGS += -ccbin $(CC)

	# FIXME: It appears that nvcc emits some intermediate C code that uses GNU extensions. The build
	# fails due to the "-pedantic" flag in the host compiler. Thus, we are forced to remove it.
	NVFLAGS += $(patsubst -%, --compiler-options=-%, $(patsubst -pedantic,, $(CFLAGS)))

	NVFLAGS += $(patsubst -%, --compiler-options=-%, $(LINEAR_ALGEBRA_INC))
endif

#
# General rules:
#

PHONY += all modules drivers tools tests

all: modules drivers
modules: libmpi.o math.o fgh.o pes.o numerov.o
drivers: atom+diatom_fgh_basis.out atom+diatom_coupling_matrix.out numerov.out smatrix.out pes_view.out
tools: fgh_basis_view.out sphe_harmonics.out sphe_bessel.out percival_seaton_coeff.out
tests: mpi_ring.out gemm_timer.out mpi_print.out mpi_tasks.out numerov_benchmark.out

#
# Rules for modules:
#

MOD_DIR = modules
ESSENTIALS = $(CHECKLIST) $(wildcard $(MOD_DIR)/*.h)

libmpi.o: $(MOD_DIR)/libmpi.cc $(ESSENTIALS)
ifeq ($(USE_MPI), yes)
	@echo "$<:"
	$(CC) $(CFLAGS) -DUSE_MPI -c $<
	@echo
else
	@echo "$<:"
	$(CC) $(CFLAGS) -c $<
	@echo
endif

math.o: $(MOD_DIR)/math.cc $(ESSENTIALS)
	@echo "$<:"
	$(CC) $(CFLAGS) -c $<
	@echo

fgh.o: $(MOD_DIR)/fgh.cc $(ESSENTIALS)
	@echo "$<:"
	$(CC) $(CFLAGS) -c $<
	@echo

pes.o: $(MOD_DIR)/pes.cc $(ESSENTIALS)
	@echo "$<:"
	$(CC) $(CFLAGS) -c $<
	@echo

numerov.o: $(MOD_DIR)/numerov.cc $(ESSENTIALS)
	@echo "$<:"
	$(CC) $(CFLAGS) $(LINEAR_ALGEBRA_INC) -c $<
	@echo

#
# Rules for drivers:
#

DRIVER_DIR = drivers

atom+diatom_fgh_basis.out: $(DRIVER_DIR)/atom+diatom_fgh_basis.cc pes.o fgh.o math.o $(ESSENTIALS)
	@echo "$<:"
	$(CC) $(CFLAGS) $(LINEAR_ALGEBRA_INC) $< -o $@ pes.o fgh.o math.o $(LDFLAGS) $(LINEAR_ALGEBRA_LIB)
	@echo

atom+diatom_coupling_matrix.out: $(DRIVER_DIR)/atom+diatom_coupling_matrix.cc numerov.o libmpi.o math.o pes.o fgh.o $(ESSENTIALS)
	@echo "$<:"
	$(CC) $(CFLAGS) $< -o $@ numerov.o libmpi.o math.o pes.o fgh.o $(LDFLAGS) $(LINEAR_ALGEBRA_LIB)
	@echo

pes_view.out: $(DRIVER_DIR)/pes_view.cc pes.o math.o $(ESSENTIALS)
	@echo "$<:"
	$(CC) $(CFLAGS) $< -o $@ pes.o math.o $(LDFLAGS)
	@echo

numerov.out: $(DRIVER_DIR)/numerov.cc numerov.o fgh.o libmpi.o math.o $(ESSENTIALS)
	@echo "$<:"
	$(CC) $(CFLAGS) $< -o $@ numerov.o fgh.o libmpi.o math.o $(LDFLAGS) $(LINEAR_ALGEBRA_LIB)
	@echo

smatrix.out: $(DRIVER_DIR)/smatrix.cc fgh.o numerov.o libmpi.o math.o $(ESSENTIALS)
	@echo "$<:"
	$(CC) $(CFLAGS) $< -o $@ fgh.o numerov.o libmpi.o math.o $(LDFLAGS) $(LINEAR_ALGEBRA_LIB)
	@echo

#
# Rules for tests:
#

TEST_DIR = testbeds

mpi_ring.out: $(TEST_DIR)/mpi_ring.cc libmpi.o $(ESSENTIALS)
	@echo "$<:"
	$(CC) $(CFLAGS) $< -o $@ libmpi.o $(LDFLAGS)
	@echo

gemm_timer.out: $(TEST_DIR)/gemm_timer.cc $(ESSENTIALS)
	@echo "$<:"
ifeq ($(USE_CUDA), yes)
	$(NVCC) $(NVFLAGS) $< -o $@ $(LDFLAGS) $(LINEAR_ALGEBRA_LIB)
else
	$(CC) $(CFLAGS) $(LINEAR_ALGEBRA_INC) $< -o $@ $(LDFLAGS) $(LINEAR_ALGEBRA_LIB)
endif
	@echo

mpi_print.out: $(TEST_DIR)/mpi_print.cc libmpi.o $(ESSENTIALS)
	@echo "$<:"
	$(CC) $(CFLAGS) $< -o $@ libmpi.o $(LDFLAGS)
	@echo

mpi_tasks.out: $(TEST_DIR)/mpi_tasks.cc libmpi.o $(ESSENTIALS)
	@echo "$<:"
	$(CC) $(CFLAGS) $< -o $@ libmpi.o $(LDFLAGS)
	@echo

numerov_benchmark.out: $(TEST_DIR)/numerov_benchmark.cc numerov.o pes.o math.o fgh.o $(ESSENTIALS)
	@echo "$<:"
	$(CC) $(CFLAGS) $< -o $@ numerov.o pes.o math.o fgh.o $(LDFLAGS) $(LINEAR_ALGEBRA_LIB)
	@echo

#
# Rules for tools:
#

TOOLS_DIR = tools

fgh_basis_view.out: $(TOOLS_DIR)/fgh_basis_view.cc fgh.o $(ESSENTIALS)
	@echo "$<:"
	$(CC) $(CFLAGS) $< -o $@ fgh.o $(LDFLAGS)
	@echo

sphe_harmonics.out: $(TOOLS_DIR)/sphe_harmonics.cc math.o $(ESSENTIALS)
	@echo "$<:"
	$(CC) $(CFLAGS) $< -o $@ math.o $(LDFLAGS)
	@echo

sphe_bessel.out: $(TOOLS_DIR)/sphe_bessel.cc math.o $(ESSENTIALS)
	@echo "$<:"
	$(CC) $(CFLAGS) $< -o $@ math.o $(LDFLAGS)
	@echo

percival_seaton_coeff.out: $(TOOLS_DIR)/percival_seaton_coeff.cc math.o $(ESSENTIALS)
	@echo "$<:"
	$(CC) $(CFLAGS) $< -o $@ math.o $(LDFLAGS)
	@echo

wigner_3j.out: $(TOOLS_DIR)/wigner_3j.cc math.o $(ESSENTIALS)
	@echo "$<:"
	$(CC) $(CFLAGS) $< -o $@ math.o $(LDFLAGS)
	@echo

wigner_6j.out: $(TOOLS_DIR)/wigner_6j.cc math.o $(ESSENTIALS)
	@echo "$<:"
	$(CC) $(CFLAGS) $< -o $@ math.o $(LDFLAGS)
	@echo

wigner_9j.out: $(TOOLS_DIR)/wigner_9j.cc math.o $(ESSENTIALS)
	@echo "$<:"
	$(CC) $(CFLAGS) $< -o $@ math.o $(LDFLAGS)
	@echo

legendre_poly.out: $(TOOLS_DIR)/legendre_poly.cc math.o $(ESSENTIALS)
	@echo "$<:"
	$(CC) $(CFLAGS) $< -o $@ math.o $(LDFLAGS)
	@echo

smatrix_view.out: $(TOOLS_DIR)/smatrix_view.cc fgh.o numerov.o math.o $(ESSENTIALS)
	@echo "$<:"
	$(CC) $(CFLAGS) $< -o $@ fgh.o numerov.o math.o $(LDFLAGS) $(LINEAR_ALGEBRA_LIB)
	@echo

#
# Rules to build and install external libraries:
#

PHONY += gsl lapacke magma openmpi

LIB_DIR = vendors

GSL_SRC = gsl-2.7.1
MAGMA_SRC = magma-2.8.0
LAPACKE_SRC = lapack-3.12.0
OPENMPI_SRC = openmpi-5.0.3

gsl: $(LIB_DIR)/$(GSL_SRC).tar.gz check_gsl_dir
	tar -zxvf $<
	cd $(GSL_SRC)/; ./configure CC=$(CC) --prefix=$(GSL_DIR); make; make install
	rm -rf $(GSL_SRC)

lapacke: $(LIB_DIR)/$(LAPACKE_SRC).tar.gz check_lapacke_dir
	tar -xvf $<
	mkdir $(LAPACKE_DIR)/lib; mkdir $(LAPACKE_DIR)/include
	cp $(LAPACKE_SRC)/make.inc.example $(LAPACKE_SRC)/make.inc
	cd $(LAPACKE_SRC)/BLAS/SRC/; make $(BLAS_CONFIG)
	cd $(LAPACKE_SRC)/; make $(LAPACK_CONFIG); make lapackelib
	cp $(LAPACKE_SRC)/lib*.a $(LAPACKE_DIR)/lib/; cp $(LAPACKE_SRC)/LAPACKE/include/*.h $(LAPACKE_DIR)/include/
	rm -rf $(LAPACKE_SRC)

magma: $(LIB_DIR)/$(MAGMA_SRC).tar.gz check_mkl_dir check_cuda_dir check_magma_dir
	tar -zxvf $<
	cp $(MAGMA_SRC)/make.inc-examples/make.inc.mkl-icc $(MAGMA_SRC)/make.inc
	cd $(MAGMA_SRC)/; export CUDADIR=$(CUDA_PATH); export GPU_TARGET="Maxwell Pascal"; make; make install prefix=$(MAGMA_DIR);
	rm -rf $(MAGMA_SRC)

openmpi: $(LIB_DIR)/$(OPENMPI_SRC).tar.bz2
	bzip2 -dk $<
	mv $(LIB_DIR)/$(OPENMPI_SRC).tar .; tar -xvf $(OPENMPI_SRC).tar
	cd $(OPENMPI_SRC)/; ./configure --prefix=$(OPENMPI_DIR); make; make install
	rm -rf $(OPENMPI_SRC).tar $(OPENMPI_SRC)

#
# Utils:
#

PHONY += clean check_gsl_dir check_mkl_dir check_lapacke_dir check_magma_dir check_atlas_dir check_cuda_dir check_fort

clean:
	rm -f *.o *.out

check_gsl_dir:
ifndef GSL_DIR
	$(error The GSL_DIR variable is not set)
endif
	@test -d $(GSL_DIR) || { echo "Unable to find GSL_DIR=$(GSL_DIR)"; exit 666; }

check_mkl_dir:
ifndef MKLROOT
	$(error The MKLROOT environment variable is not set)
endif
	@test -d $(MKLROOT) || { echo "Unable to find MKLROOT=$(MKLROOT)"; exit 666; }

check_lapacke_dir: check_fort
ifndef LAPACKE_DIR
	$(error The LAPACKE_DIR variable is not set)
endif
	@test -d $(LAPACKE_DIR) || { echo "Unable to find LAPACKE_DIR=$(LAPACKE_DIR)"; exit 666; }

check_magma_dir:
ifndef MAGMA_DIR
	$(error The MAGMA_DIR variable is not set)
endif
	@test -d $(MAGMA_DIR) || { echo "Unable to find MAGMA_DIR=$(MAGMA_DIR)"; exit 666; }

check_atlas_dir:
ifndef ATLAS_DIR
	$(error The ATLAS_DIR variable is not set)
endif
	@test -d $(ATLAS_DIR) || { echo "Unable to find ATLAS_DIR=$(ATLAS_DIR)"; exit 666; }

check_cuda_dir:
ifndef CUDA_PATH
	$(error The CUDA_PATH environment variable is not set)
endif
	@test -d $(CUDA_PATH) || { echo "Unable to find CUDA_PATH=$(CUDA_PATH)"; exit 666; }

check_fort:
ifeq ($(FC), none)
	$(error A Fortran compiler is required on the FC variable)
endif

.PHONY: $(PHONY)
