SHELL = /bin/sh

#
# GNU Scientific Library: The installation path of GSL must be provided in the
# GSL_DIR variable, and it's to be validated by the check_gsl_dir rule defined
# below. The default path of GSL is /usr/local, but it isn't used herein because
# it exists in most systems even if GSL is not installed.
#

GSL_DIR =
LINEAR_ALGEBRA = GSL

#
# Default compiler: GNU g++ is the default option when the CC variable is omitted.
# The Intel icx compiler (previously icpc) uses the same flags as g++, thus the
# makefile will use the same CFLAGS and LDFLAGS variables. The use of OpenMP is
# implied. Valid values for CC are: g++, icx, icpc, clang, ibm-clang++ and pgcc.
#

CC = g++
LDFLAGS = -L$(GSL_DIR)/lib -lgsl -lgslcblas -lm
CFLAGS = -std=c++17 -pedantic -Wall -Wconversion -fopenmp -O3 -I$(GSL_DIR)/include

#
# MPI wrappers: If the CC variable is set to an MPI wrapper of a given compiler
# (e.g., CC=mpic++), then the internal variable USE_MPI=yes is used to trigger
# all MPI-related configuration and the C++ branches using MPI.
#

USE_MPI = no
OPENMPI_DIR =

ifeq ($(CC), mpic++)
	USE_MPI = yes
endif

ifeq ($(CC), mpicxx)
	USE_MPI = yes
endif

ifeq ($(CC), mpiicpc)
	USE_MPI = yes
endif

ifeq ($(CC), mpiicx)
	USE_MPI = yes
endif

ifeq ($(CC), mpiCC)
	USE_MPI = yes
endif

#
# LLVM clang compiler: The same LDFLAGS of GNU g++ is used and CFLAGS is nearly
# identical.
#

ifeq ($(CC), clang)
	override CFLAGS = -std=c++17 -pedantic-errors -Wall -fopenmp=libomp -O3 -I$(GSL_DIR)/include
endif

#
# IBM Open XL compiler (clang frontend): The classic XL compilers didn't support
# C++17.
#

ifeq ($(CC), ibm-clang++)
	override CFLAGS = -std=c++17 -pedantic-errors -Wall -fopenmp=libomp -O3 -I$(GSL_DIR)/include
endif

#
# PGI pgcc compiler: The same LDFLAGS of GNU g++ is used.
#

ifeq ($(CC), pgcc)
	override CFLAGS = -Xc -mp -O3 -I$(GSL_DIR)/include
endif

#
# Nvidia nvcc compiler: Since there is only one CUDA compiler, instead of using the CC
# variable to set the compiler name and presets, use the variable USE_CUDA=yes. The CC
# variable and its CFLAGS is passed to nvcc as the host compiler for the C++ parts of
# the code.
#

USE_CUDA = no

NVCC = nvcc
NVFLAGS = -std=c++17 --Werror all-warnings --threads 0

ifeq ($(USE_CUDA), yes)
	LINEAR_ALGEBRA_INC = -I$(CUDA_PATH)/include
	LINEAR_ALGEBRA_LIB = -L$(CUDA_PATH)/lib64

	# FIXME: It appears that nvcc emits some intermediate C code that uses GNU extensions. The build
	# fails due to the -pedantic flag in the host compiler. Thus, we are forced to remove it.
	NVFLAGS += -ccbin $(CC) $(patsubst -%, --compiler-options=-%, $(patsubst -pedantic,, $(CFLAGS)))
endif

#
# Fortran compilers: If linkage of object files generated by Fortran compilers is
# needed, the variable FC is used to set the compiler name, and the core libraries
# will be added to LDFLAGS. Valid values for FC are: xlf, xlf90, gfortran and ifort.
# Undefined references to Fortran symbols are likely to be solved by setting FC.
#

FC =

#
# Intel MKL: Only for GNU g++ and Intel icx (icpc) compilers. The environment
# variable MKLROOT is used and needs to have been exported elsewhere.
#

MKL_DIR = $(MKLROOT)

ifeq ($(LINEAR_ALGEBRA), MKL)
	LINEAR_ALGEBRA_INC = -DMKL_ILP64 -m64 -I$(MKL_DIR)/include -DUSE_MKL

	ifeq ($(CC), icpc)
		LINEAR_ALGEBRA_LIB = -parallel -Wl,--start-group $(MKL_DIR)/lib/intel64/libmkl_intel_ilp64.a $(MKL_DIR)/lib/intel64/libmkl_intel_thread.a $(MKL_DIR)/lib/intel64/libmkl_core.a -Wl,--end-group -liomp5 -lpthread -lm -ldl
	endif

	ifeq ($(CC), mpiicpc)
		LINEAR_ALGEBRA_LIB = -parallel -Wl,--start-group $(MKL_DIR)/lib/intel64/libmkl_intel_ilp64.a $(MKL_DIR)/lib/intel64/libmkl_intel_thread.a $(MKL_DIR)/lib/intel64/libmkl_core.a -Wl,--end-group -liomp5 -lpthread -lm -ldl
	endif

	ifeq ($(CC), g++)
		LINEAR_ALGEBRA_LIB = -Wl,--start-group $(MKL_DIR)/lib/intel64/libmkl_intel_ilp64.a $(MKL_DIR)/lib/intel64/libmkl_gnu_thread.a $(MKL_DIR)/lib/intel64/libmkl_core.a -Wl,--end-group -lgomp -lpthread -lm -ldl
	endif

	ifeq ($(CC), mpic++)
		LINEAR_ALGEBRA_LIB = -Wl,--start-group $(MKL_DIR)/lib/intel64/libmkl_intel_ilp64.a $(MKL_DIR)/lib/intel64/libmkl_gnu_thread.a $(MKL_DIR)/lib/intel64/libmkl_core.a -Wl,--end-group -lgomp -lpthread -lm -ldl
	endif
endif

#
# LAPACKE, LAPACK and BLAS libraries: The default installation path is /usr/local.
# The variables BLAS_CONFIG and LAPACK_CONFIG are only used to build the libraries
# from source in the lapacke rule.
#

LAPACKE_DIR =
LAPACK_DIR = $(LAPACKE_DIR)
BLAS_DIR = $(LAPACKE_DIR)

ifeq ($(LINEAR_ALGEBRA), LAPACKE)
	LINEAR_ALGEBRA_INC = -I$(LAPACKE_DIR)/include -DUSE_LAPACKE
	LINEAR_ALGEBRA_LIB = -L$(LAPACKE_DIR)/lib -L$(LAPACKE_DIR)/lib64 -llapacke -llapack -lrefblas -lm
endif

BLAS_CONFIG = FORTRAN=$(FC)
LAPACK_CONFIG = FORTRAN=$(FC) LOADER=$(FC) CC=$(CC) NOOPT=-O0 TIMER=NONE

ifeq ($(FC), gfortran)
	BLAS_CONFIG += OPTS=-O3
	LAPACK_CONFIG += CFLAGS=-O3 OPTS=-O3
endif

ifeq ($(FC), ifort)
	BLAS_CONFIG += OPTS=-O3
	LAPACK_CONFIG += CFLAGS=-O3 OPTS=-O3
endif

ifeq ($(FC), xlf)
	BLAS_CONFIG += OPTS="-qstrict -O5"
	LAPACK_CONFIG += CFLAGS="-qstrict -O5" OPTS="-qstrict -O5"
endif

ifeq ($(FC), xlf90)
	BLAS_CONFIG += OPTS="-qstrict -O5"
	LAPACK_CONFIG += CFLAGS="-qstrict -O5" OPTS="-qstrict -O5"
endif

#
# IBM ESSL:
# FIXME: This hasn't been tested in great detail, and the C++ specific impl.
# isn't ready (earlier tests used C and Fortran).
#

ESSL_DIR =

ifeq ($(LINEAR_ALGEBRA), ESSL)
	LINEAR_ALGEBRA_INC = -I$(ESSL_DIR)/include -DUSE_ESSL
	LINEAR_ALGEBRA_LIB = -L$(ESSL_DIR)/lib64 -lesslbg -lm
endif

#
# CUDA: The variable USE_CUDA=yes will trigger all CUDA-related configuration.
#

USE_CUDA = no
CUDA_DIR = $(CUDA_PATH)

ifeq ($(USE_CUDA), yes)
	LINEAR_ALGEBRA_INC = -I$(CUDA_DIR)/include
	LINEAR_ALGEBRA_LIB = -L$(CUDA_DIR)/lib64
endif

#
# MAGMA library:
#

MAGMA_DIR = /usr/local/magma

ifeq ($(LINEAR_ALGEBRA), MAGMA)
	CFLAGS += -DUSE_MAGMA
	LINEAR_ALGEBRA_INC += -I$(MAGMA_DIR)/include -DADD_
	LINEAR_ALGEBRA_LIB += -L$(MAGMA_DIR)/lib -lmagma -lm
endif

#
# ATLAS library:
#

ATLAS_DIR = /usr/local/atlas

ifeq ($(LINEAR_ALGEBRA), ATLAS)
	LINEAR_ALGEBRA_INC = -I$(ATLAS_DIR)/include -DUSE_ATLAS
	LINEAR_ALGEBRA_LIB = -L$(ATLAS_DIR)/lib -latlas -lptcblas -lm
endif

#
# Fortran core libraries: This is done late because core libraries are appended
# in the rightmost position within the linking command line.
#

XLF_DIR = /opt/ibmcmp/xlf

ifeq ($(FC), xlf)
	LDFLAGS += -L$(XLF_DIR)/lib -lxlf90 -lxl -lxlfmath

	ifeq ($(LINEAR_ALGEBRA), LAPACKE)
		LINEAR_ALGEBRA_LIB += L$(XLF_DIR)/lib -lxlf90 -lxl -lxlfmath
	endif
endif

ifeq ($(FC), xlf90)
	LDFLAGS += -L$(XLF_DIR)/lib -lxlf90 -lxl -lxlfmath

	ifeq ($(LINEAR_ALGEBRA), LAPACKE)
		LINEAR_ALGEBRA_LIB += -L$(XLF_DIR)/lib -lxlf90 -lxl -lxlfmath
	endif
endif

ifeq ($(FC), gfortran)
	LDFLAGS += -lgfortran

	ifeq ($(LINEAR_ALGEBRA), LAPACKE)
		LINEAR_ALGEBRA_LIB += -lgfortran
	endif
endif

ifeq ($(FC), ifort)
	LDFLAGS += -lifcore

	ifeq ($(LINEAR_ALGEBRA), LAPACKE)
		LINEAR_ALGEBRA_LIB += -lifcore
	endif
endif

#
# General rules:
#

PHONY += all modules drivers tools tests

all: modules drivers
modules: libmpi.o liblapack.o math.o fgh.o pes.o spline.o numerov.o
drivers: atom+diatom_fgh_basis.out atom+diatom_coupling_matrix.out pes_view.out
tools: fgh_basis_view.out sphe_harmonics.out
tests: mpi_ring.out gemm_timer.out mpi_print.out mpi_tasks.out numerov_benchmark.out

#
# Rules for modules:
#

MOD_DIR = modules
ESSENTIALS = check_gsl_dir $(wildcard $(MOD_DIR)/*.h)

libmpi.o: $(MOD_DIR)/libmpi.cc $(ESSENTIALS)
ifeq ($(USE_MPI), yes)
	@echo "$<:"
	$(CC) $(CFLAGS) -DUSE_MPI -c $<
	@echo
else
	@echo "$<:"
	$(CC) $(CFLAGS) -c $<
	@echo
endif

liblapack.o: $(MOD_DIR)/liblapack.cc $(ESSENTIALS)
	@echo "$<:"
	$(CC) $(CFLAGS) $(LINEAR_ALGEBRA_INC) -c $<
	@echo

math.o: $(MOD_DIR)/math.cc $(ESSENTIALS)
	@echo "$<:"
	$(CC) $(CFLAGS) -c $<
	@echo

fgh.o: $(MOD_DIR)/fgh.cc $(ESSENTIALS)
	@echo "$<:"
	$(CC) $(CFLAGS) -c $<
	@echo

pes.o: $(MOD_DIR)/pes.cc $(ESSENTIALS)
	@echo "$<:"
	$(CC) $(CFLAGS) -c $<
	@echo

spline.o: $(MOD_DIR)/spline.cc $(ESSENTIALS)
	@echo "$<:"
	$(CC) $(CFLAGS) -c $<
	@echo

numerov.o: $(MOD_DIR)/numerov.cc $(ESSENTIALS)
	@echo "$<:"
	$(CC) $(CFLAGS) -c $<
	@echo

#
# Rules for drivers:
#

DRIVER_DIR = drivers

atom+diatom_fgh_basis.out: $(DRIVER_DIR)/atom+diatom_fgh_basis.cc pes.o fgh.o liblapack.o math.o $(ESSENTIALS)
	@echo "$<:"
	$(CC) $(CFLAGS) $< -o $@ pes.o fgh.o liblapack.o math.o $(LDFLAGS) $(LINEAR_ALGEBRA_LIB)
	@echo

atom+diatom_coupling_matrix.out: $(DRIVER_DIR)/atom+diatom_coupling_matrix.cc libmpi.o math.o pes.o fgh.o $(ESSENTIALS)
	@echo "$<:"
	$(CC) $(CFLAGS) $< -o $@ libmpi.o math.o pes.o fgh.o $(LDFLAGS)
	@echo

pes_view.out: $(DRIVER_DIR)/pes_view.cc pes.o math.o $(ESSENTIALS)
	@echo "$<:"
	$(CC) $(CFLAGS) $< -o $@ pes.o math.o $(LDFLAGS)
	@echo

#
# Rules for tests:
#

TEST_DIR = testbeds

mpi_ring.out: $(TEST_DIR)/mpi_ring.cc libmpi.o $(ESSENTIALS)
	@echo "$<:"
	$(CC) $(CFLAGS) $< -o $@ libmpi.o $(LDFLAGS)
	@echo

gemm_timer.out: $(TEST_DIR)/gemm_timer.cc liblapack.o $(ESSENTIALS)
	@echo "$<:"
	$(CC) $(CFLAGS) $< -o $@ liblapack.o $(LDFLAGS) $(LINEAR_ALGEBRA_LIB)
	@echo

mpi_print.out: $(TEST_DIR)/mpi_print.cc libmpi.o $(ESSENTIALS)
	@echo "$<:"
	$(CC) $(CFLAGS) $< -o $@ libmpi.o $(LDFLAGS)
	@echo

mpi_tasks.out: $(TEST_DIR)/mpi_tasks.cc libmpi.o $(ESSENTIALS)
	@echo "$<:"
	$(CC) $(CFLAGS) $< -o $@ libmpi.o $(LDFLAGS)
	@echo

numerov_benchmark.out: $(TEST_DIR)/numerov_benchmark.cc liblapack.o numerov.o pes.o math.o $(ESSENTIALS)
	@echo "$<:"
	$(CC) $(CFLAGS) $< -o $@ liblapack.o numerov.o pes.o math.o $(LDFLAGS) $(LINEAR_ALGEBRA_LIB)
	@echo

#
# Rules for tools:
#

TOOLS_DIR = tools

fgh_basis_view.out: $(TOOLS_DIR)/fgh_basis_view.cc fgh.o $(ESSENTIALS)
	@echo "$<:"
	$(CC) $(CFLAGS) $< -o $@ fgh.o $(LDFLAGS)
	@echo

sphe_harmonics.out: $(TOOLS_DIR)/sphe_harmonics.cc math.o $(ESSENTIALS)
	@echo "$<:"
	$(CC) $(CFLAGS) $< -o $@ math.o $(LDFLAGS)
	@echo

#
# Rules to build and install external libraries:
#

PHONY += gsl lapacke magma openmpi

LIB_DIR = libs

gsl: $(LIB_DIR)/gsl-2.7.1.tar.gz check_gsl_dir
	tar -zxvf $<
	cd gsl-2.7.1/; ./configure CC=$(CC) --prefix=$(GSL_DIR); make; make install
	rm -rf gsl-2.7.1

lapacke: $(LIB_DIR)/lapack-3.12.0.tar.gz
	tar -xvf $<
	mkdir $(LAPACKE_DIR)/lib
	mkdir $(LAPACKE_DIR)/include
	cd lapack-3.12.0/; cp make.inc.example make.inc
	cd lapack-3.12.0/BLAS/SRC; make $(BLAS_CONFIG)
	cd lapack-3.12.0; make $(LAPACK_CONFIG); make lapackelib
	cd lapack-3.12.0; cp lib*.a $(LAPACKE_DIR)/lib/; cp LAPACKE/include/*.h $(LAPACKE_DIR)/include/
	rm -rf lapack-3.12.0

magma: $(LIB_DIR)/magma-2.5.1-alpha1.tar.gz $(CUDA_DIR) $(MAGMA_DIR)
	tar -zxvf $<
	cp magma-2.5.1-alpha1/make.inc-examples/make.inc.mkl-$(CC) magma-2.5.1-alpha1/make.inc
	cd magma-2.5.1-alpha1/; export CUDADIR=$(CUDA_DIR); export GPU_TARGET="Kepler Maxwell Pascal"; make; make install prefix=$(MAGMA_DIR);
	rm -rf magma-2.5.1-alpha1

openmpi: $(LIB_DIR)/openmpi-5.0.3.tar.bz2
	bzip2 -dk $<
	mv $(LIB_DIR)/openmpi-5.0.3.tar .
	tar -xvf openmpi-5.0.3.tar
	cd openmpi-5.0.3; ./configure --prefix=$(OPENMPI_DIR); make; make install
	rm -rf openmpi-5.0.3.tar openmpi-5.0.3

#
# Utils:
#

PHONY += clean check_gsl_dir

clean:
	rm -f *.o *.out

check_gsl_dir:
ifndef GSL_DIR
	$(error The GSL_DIR variable is not set)
endif
	@test -d $(GSL_DIR) || { echo "Unable to find GSL_DIR=$(GSL_DIR)"; exit 666; }

.PHONY: $(PHONY)
